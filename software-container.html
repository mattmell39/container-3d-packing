<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Packing 3D testuale + grafica</title>
<style>
body{margin:0;font-family:system-ui, sans-serif;background:#0f172a;color:#e2e8f0;padding:20px}
h1{font-size:22px;margin-bottom:10px}
.card{background:#1e293b;border-radius:10px;padding:16px;margin-bottom:16px}
label{display:block;font-size:13px;color:#94a3b8;margin-bottom:4px}
input{width:100%;padding:8px;border-radius:6px;border:1px solid #334155;background:#0f172a;color:#f8fafc;margin-bottom:4px}
input[type=range]{width:100%;}
.row{display:flex;gap:10px;margin-bottom:8px}
.col{flex:1}
.blocks-list{display:flex;flex-direction:column;gap:8px;max-height:300px;overflow:auto}
.block-item{display:grid;grid-template-columns:60px repeat(4,1fr) 80px;gap:6px;align-items:end}
button{cursor:pointer;padding:6px 10px;border-radius:6px;border:none;font-weight:600;background:#38bdf8;color:#0f172a}
.progress-bar-container{background:#334155;border-radius:6px;overflow:hidden;margin-top:6px}
.progress-bar{height:16px;background:#22c55e;width:0%}
.result{background:#0f172a;border-radius:8px;padding:12px;margin-top:12px;white-space:pre-wrap;font-family:monospace}
.canvas-container{display:flex;flex-direction:column;gap:16px;margin-top:16px}
.container-canvas{background:#1e293b;padding:6px;border-radius:8px;text-align:center}
</style>
</head>
<body>
<h1>Packing 3D testuale — Software per riempimento container</h1>

<div class="card">
  <h2>Dimensioni container</h2>
  <div class="row">
    <div class="col"><label>Lunghezza (cm)</label><input id="contL" type="number" value="600"></div>
    <div class="col"><label>Larghezza (cm)</label><input id="contW" type="number" value="230"></div>
    <div class="col"><label>Altezza (cm)</label><input id="contH" type="number" value="230"></div>
  </div>
  <div class="row">
    <div class="col"><label>Margine (cm)</label><input id="margin" type="number" value="10"></div>
    <div class="col"><label>Peso max (t)</label><input id="maxWeight" type="number" value="27"></div>
  </div>
</div>

<div class="card">
  <h2>Blocchi</h2>
  <div class="row">
    <div class="col"><strong>ID</strong></div>
    <div class="col"><strong>Lunghezza</strong></div>
    <div class="col"><strong>Larghezza</strong></div>
    <div class="col"><strong>Altezza</strong></div>
    <div class="col"><strong>Peso</strong></div>
    <div class="col"></div>
  </div>
  <div id="blocksList" class="blocks-list"></div>
  <button id="addBlock" style="margin-top:6px">+ Aggiungi blocco</button>
</div>

<div class="card">
  <h2>Simulazione Monte Carlo</h2>
  <div class="row">
    <div class="col"><label>Numero simulazioni</label><input id="maxShuffle" type="number" value="1000"></div>
  </div>
  <div class="row">
    <div class="col">
      <label>Soglia minima peso (%) <span id="minFillValue">80</span></label>
      <input id="minFillSlider" type="range" min="0" max="100" value="80">
    </div>
  </div>
  <div class="progress-bar-container">
    <div id="progressBar" class="progress-bar"></div>
  </div>
</div>

<button id="computeBtn">Calcola packing 3D</button>
<div id="result" class="result">Premi "Calcola packing 3D" per vedere i risultati.</div>
<div id="canvasContainer" class="canvas-container"></div>

<script>
let blockCounter=0;
const blocksList = document.getElementById('blocksList');
const minFillSlider = document.getElementById('minFillSlider');
const minFillValue = document.getElementById('minFillValue');
minFillSlider.oninput = ()=>minFillValue.textContent = minFillSlider.value;

const initialBlocks=[
{id:3320, l:222,w:90,h:65,wt:3.03},{id:3321, l:235,w:152,h:127,wt:8.75},
{id:3322, l:252,w:149,h:108,wt:8.89},{id:3323, l:223,w:167,h:64,wt:5.63},
{id:3324, l:307,w:158,h:141,wt:15.26},{id:3325, l:235,w:157,h:168,wt:12.69},
{id:3326, l:262,w:154,h:94,wt:7.71},{id:3327, l:260,w:148,h:100,wt:7.43},
{id:3328, l:192,w:149,h:150,wt:9.85},{id:3329, l:274,w:146,h:163,wt:14.18},
{id:3330, l:240,w:154,h:173,wt:13.82},{id:3331, l:268,w:146,h:133,wt:11.80},
{id:3332, l:263,w:150,h:147,wt:12.99},{id:3333, l:226,w:163,h:90,wt:7.70},
{id:3334, l:216,w:138,h:72,wt:4.71},{id:3335, l:233,w:159,h:123,wt:10.54},
{id:3336, l:300,w:149,h:150,wt:14.19},{id:3337, l:306,w:106,h:115,wt:7.82},
{id:3338, l:320,w:129,h:86,wt:8.14},{id:3339, l:253,w:149,h:132,wt:11.92},
{id:3340, l:290,w:144,h:100,wt:5.76},{id:3341, l:314,w:160,h:160,wt:15.70},
{id:3342, l:321,w:166,h:148,wt:16.33},{id:3343, l:200,w:157,h:103,wt:7.15},
{id:3344, l:310,w:142,h:93,wt:9.46},{id:3345, l:222,w:134,h:107,wt:6.76},
{id:3346, l:272,w:123,h:94,wt:6.52}
];

function makeBlockRow(b){
  const row=document.createElement('div');
  row.className='block-item';
  row.dataset.blockId=b.id;
  const idInput=document.createElement('input'); idInput.type='number'; idInput.value=b.id;
  const lInput=document.createElement('input'); lInput.type='number'; lInput.value=b.l;
  const wInput=document.createElement('input'); wInput.type='number'; wInput.value=b.w;
  const hInput=document.createElement('input'); hInput.type='number'; hInput.value=b.h;
  const wtInput=document.createElement('input'); wtInput.type='number'; wtInput.value=b.wt;
  const removeBtn=document.createElement('button'); removeBtn.textContent='Rimuovi';
  removeBtn.onclick=()=>row.remove();
  row.append(idInput,lInput,wInput,hInput,wtInput,removeBtn);
  return row;
}

function addBlock(l=100,w=100,h=100,wt=1,id=null){
  blockCounter++;
  const b={id:id??(3346+blockCounter),l:parseInt(l),w:parseInt(w),h:parseInt(h),wt:parseFloat(wt)};
  blocksList.appendChild(makeBlockRow(b));
}

function readBlocks(){
  return [...blocksList.querySelectorAll('.block-item')].map(r=>{
    const inputs = r.querySelectorAll('input');
    const id = +inputs[0].value;
    const l  = +inputs[1].value;
    const w  = +inputs[2].value;
    const h  = +inputs[3].value;
    const wt = +inputs[4].value;
    return {id,l,w,h,wt};
  });
}

initialBlocks.forEach(b=>addBlock(b.l,b.w,b.h,b.wt,b.id));

function rotations(b){ return [[b.l,b.w,b.h],[b.l,b.h,b.w],[b.w,b.l,b.h],[b.w,b.h,b.l],[b.h,b.l,b.w],[b.h,b.w,b.l]]; }
function fits(box,dims){ return dims[0]<=box.dx && dims[1]<=box.dy && dims[2]<=box.dz; }
function splitFree(free,placed){
  const res=[]; const fx=free.x,fy=free.y,fz=free.z,fdx=free.dx,fdy=free.dy,fdz=free.dz;
  const bx=placed.dx,by=placed.dy,bz=placed.dz;
  if(fdx-bx>0) res.push({x:fx+bx,y:fy,z:fz,dx:fdx-bx,dy:fdy,dz:fdz});
  if(fdy-by>0) res.push({x:fx,y:fy+by,z:fz,dx:bx,dy:fdy-by,dz:fdz});
  if(fdz-bz>0) res.push({x:fx,y:fy,z:fz+bz,dx:bx,dy:by,dz:fdz-bz});
  return res;
}

function packContainer(containerDims,maxWeight,blocks){
  const freeList=[{x:0,y:0,z:0,dx:containerDims.L,dy:containerDims.W,dz:containerDims.H}];
  const placed=[]; let usedWeight=0;
  for(const b of blocks){
    let ok=false;
    for(let fi=0;fi<freeList.length && !ok;fi++){
      const f=freeList[fi];
      for(const r of rotations(b)){
        const [dx,dy,dz]=r;
        if(!fits(f,[dx,dy,dz])) continue;
        if(usedWeight+b.wt>maxWeight) continue;
        placed.push({block:b,x:f.x,y:f.y,z:f.z,dx,dy,dz});
        usedWeight+=b.wt;
        const newBoxes=splitFree(f,placed[placed.length-1]);
        freeList.splice(fi,1); freeList.push(...newBoxes); ok=true; break;
      }
    }
  }
  let maxX=0,maxY=0,maxZ=0;
  for(const p of placed){ maxX=Math.max(maxX,p.x+p.dx); maxY=Math.max(maxY,p.y+p.dy); maxZ=Math.max(maxZ,p.z+p.dz); }
  return {placed,usedWeight,fillPerc:{L:maxX/containerDims.L*100,W:maxY/containerDims.W*100,H:maxZ/containerDims.H*100}};
}

function shuffleArray(arr){ const a=arr.slice(); for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

async function runMonteCarlo(contDims, margin, maxWeight, maxShuffle, blocks, nDesired, minFill, progressBar) {
  let bestSolution = null;
  const resultDiv = document.getElementById('result');

  outerLoop:
  for (let nContainer = nDesired; nContainer <= nDesired + 5; nContainer++) {
    resultDiv.textContent = `Cercando la soluzione con ${nContainer} container...`;
    await new Promise(r => setTimeout(r, 0)); // consente l'aggiornamento della UI

    for (let s = 0; s < maxShuffle; s++) {
      if (s % 10 === 0) {
        progressBar.style.width = Math.round((s / maxShuffle) * 100) + '%';
        await new Promise(r => setTimeout(r, 0));
      }

      const seq = shuffleArray(blocks);
      const containers = [];
      let remaining = seq.slice();

      while (remaining.length > 0 && containers.length < nContainer) {
        const res = packContainer({ L: contDims.L - margin, W: contDims.W - margin, H: contDims.H - margin }, maxWeight, remaining);
        if (res.placed.length === 0) break;
        const placedIds = new Set(res.placed.map(p => p.block.id));
        remaining = remaining.filter(b => !placedIds.has(b.id));
        containers.push(res);
      }

      const valid = containers.every(c => c.usedWeight >= minFill * maxWeight);
      if (remaining.length === 0 && valid) {
        bestSolution = { containers, nContainer };
        break outerLoop;
      }
    }
  }

  progressBar.style.width = '100%';

  if (!bestSolution) {
    resultDiv.textContent = "⚠ Nessuna soluzione trovata. Prova ad abbassare la soglia di peso minimo %";
  }

  return bestSolution;
}

// --- Colore blocchi ---
function colorForBlock(id){ const hue=(id*137)%360; return `hsl(${hue},70%,60%)`; }

// --- Disegno container con 3 viste ---
function drawContainer(container, contDims, containerIndex){
  const canvasDiv=document.createElement('div');
  canvasDiv.className='container-canvas';

  const title=document.createElement('div');
  title.style.textAlign='center';
  title.style.marginBottom='4px';
  title.textContent=`Container ${containerIndex+1}`;
  canvasDiv.appendChild(title);

  const scale=2;

  // Vista dall’alto (L×W)
  const canvasTop=document.createElement('canvas');
  canvasTop.width=contDims.L/scale;
  canvasTop.height=contDims.W/scale;
  const ctxT=canvasTop.getContext('2d');
  ctxT.fillStyle='#334155';
  ctxT.fillRect(0,0,canvasTop.width,canvasTop.height);
  container.placed.forEach(p=>{
    const x=p.x/scale, y=p.y/scale, w=p.dx/scale, h=p.dy/scale;
    ctxT.fillStyle=colorForBlock(p.block.id);
    ctxT.fillRect(x,y,w,h);
    ctxT.fillStyle='#0f172a';
    ctxT.font='10px monospace';
    ctxT.fillText(p.block.id,x+2,y+12);
  });
  const lbl1=document.createElement('div');
  lbl1.style.textAlign='center';
  lbl1.textContent='Vista dall’alto (L×W)';
  canvasDiv.appendChild(lbl1);
  canvasDiv.appendChild(canvasTop);

  // Vista laterale (L×H)
  const canvasSide=document.createElement('canvas');
  canvasSide.width=contDims.L/scale;
  canvasSide.height=contDims.H/scale;
  const ctxS=canvasSide.getContext('2d');
  ctxS.fillStyle='#334155';
  ctxS.fillRect(0,0,canvasSide.width,canvasSide.height);
  container.placed.forEach(p=>{
    const x=p.x/scale, y=(contDims.H-p.z-p.dz)/scale, w=p.dx/scale, h=p.dz/scale;
    ctxS.fillStyle=colorForBlock(p.block.id);
    ctxS.fillRect(x,y,w,h);
    ctxS.fillStyle='#0f172a';
    ctxS.font='10px monospace';
    ctxS.fillText(p.block.id,x+2,y+12);
  });
  const lbl2=document.createElement('div');
  lbl2.style.textAlign='center';
  lbl2.textContent='Vista laterale (L×H)';
  canvasDiv.appendChild(lbl2);
  canvasDiv.appendChild(canvasSide);

  // Vista frontale (W×H) specchiata con ordinamento per profondità
  const canvasFront = document.createElement('canvas');
  canvasFront.width = contDims.W / scale;
  canvasFront.height = contDims.H / scale;
  const ctxF = canvasFront.getContext('2d');
  ctxF.fillStyle = '#334155';
  ctxF.fillRect(0, 0, canvasFront.width, canvasFront.height);

  // Ordina i blocchi in base alla profondità (p.z) per la vista frontale
  container.placed
    .slice() // copia per non modificare l'array originale
    .sort((a, b) => a.z - b.z) // disegna prima i blocchi più lontani
    .forEach(p => {
      const x = (contDims.W - (p.y + p.dy)) / scale; // specchiatura orizzontale
      const y = (contDims.H - p.z - p.dz) / scale;   // altezza inversa
      const w = p.dy / scale;
      const h = p.dz / scale;

      ctxF.fillStyle = colorForBlock(p.block.id);
      ctxF.fillRect(x, y, w, h);

      ctxF.fillStyle = '#0f172a';
      ctxF.font = '10px monospace';
      ctxF.fillText(p.block.id, x + 2, y + 12);
    });

  const lbl3 = document.createElement('div');
  lbl3.style.textAlign = 'center';
  lbl3.textContent = 'Vista frontale (W×H)';
  canvasDiv.appendChild(lbl3);
  canvasDiv.appendChild(canvasFront);

  return canvasDiv;
}

document.getElementById('computeBtn').onclick=async ()=>{
  const contDims={L:+document.getElementById('contL').value,W:+document.getElementById('contW').value,H:+document.getElementById('contH').value};
  const margin=+document.getElementById('margin').value;
  const maxWeight=+document.getElementById('maxWeight').value;
  const maxShuffle=+document.getElementById('maxShuffle').value;
  const blocks=readBlocks();
  const pesoTot=blocks.reduce((a,b)=>a+b.wt,0);
  let nDesired=Math.ceil(pesoTot/maxWeight);
  const minFill = +minFillSlider.value / 100;  
  const progressBar=document.getElementById('progressBar');
  progressBar.style.width='0%';

  const bestSolution = await runMonteCarlo(contDims, margin, maxWeight, maxShuffle, blocks, nDesired, minFill, progressBar);

  const canvasContainer=document.getElementById('canvasContainer');
  canvasContainer.innerHTML='';

  if(!bestSolution){
    document.getElementById('result').textContent = "⚠ Nessuna soluzione trovata. Prova a diminuire la soglia del peso minimo o ad incrementare il numero di simulazioni.";
    progressBar.style.width='0%';
    return;
  }

  const pesoMedioDesiderato = pesoTot / nDesired;
  const pesoMedioUsato = bestSolution.containers.reduce((a,c)=>a+c.usedWeight,0)/bestSolution.nContainer;

  let out=`Blocchi totali: ${blocks.length}\nPeso totale: ${pesoTot.toFixed(2)} t\nNumero container desiderati: ${nDesired} con peso medio di ${pesoMedioDesiderato.toFixed(3)} t\nContainer usati: ${bestSolution.nContainer}, con peso medio di ${pesoMedioUsato.toFixed(3)} t\n`;

  bestSolution.containers.forEach((c,i)=>{
    const ids=c.placed.map(p=>'B'+p.block.id);
    const pct=((c.usedWeight/maxWeight)*100).toFixed(1);
    const fill=c.fillPerc;
    out+=`\nContainer ${i+1} — blocchi: ${c.placed.length}, peso: ${c.usedWeight.toFixed(2)} t, % peso max: ${pct}%\n`;
    out+=`  Riempimento L×W×H: ${fill.L.toFixed(1)}% × ${fill.W.toFixed(1)}% × ${fill.H.toFixed(1)}%\n`;
    out+=`  IDs: ${ids.join(', ')}\n`;
  });

  document.getElementById('result').textContent=out;

  bestSolution.containers.forEach((c,i)=>{
    const cDiv=drawContainer(c, contDims, i);
    canvasContainer.appendChild(cDiv);
  });
};

document.getElementById('addBlock').onclick = ()=>addBlock();
</script>
</body>
</html>
